<!DOCTYPE html>
<html>
<head>
    <title>Memory Allocation Analyzer</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 1000px; margin: 0 auto; }
        .info { background-color: #f0f0f0; padding: 10px; border-radius: 5px; margin-bottom: 20px; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f2f2f2; }
        tr:hover { background-color: #f5f5f5; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Memory Allocation Analysis</h1>
        
        <div class="info">
            <p><strong>Instructions:</strong> Upload your <code>.speedscope.json</code> file to analyze allocation patterns.</p>
            <p>This tool helps you identify allocation hotspots and memory usage patterns without needing PerfView.</p>
        </div>
        
        <input type="file" id="fileInput" accept=".json">
        
        <div id="results" style="margin-top: 20px;">
            <div id="summary"></div>
            <h2>Top Allocation Sources</h2>
            <table id="allocTable">
                <thead>
                    <tr>
                        <th>Function</th>
                        <th>Self Time (ms)</th>
                        <th>Total Time (ms)</th>
                        <th>% of Total</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>

    <script>
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    analyzeSpeedscopeData(data);
                } catch (err) {
                    console.error('Error parsing JSON:', err);
                    document.getElementById('summary').innerHTML = '<p style="color: red">Error parsing file: ' + err.message + '</p>';
                }
            };
            reader.readAsText(file);
        });
        
        function analyzeSpeedscopeData(data) {
            // Basic validation
            if (!data.profiles || !data.profiles.length) {
                document.getElementById('summary').innerHTML = '<p style="color: red">Invalid speedscope format or no profile data found</p>';
                return;
            }
            
            const profile = data.profiles[0];
            const frames = data.shared?.frames || [];
            
            // Get frame lookup
            const frameLookup = {};
            frames.forEach((frame, index) => {
                frameLookup[index] = frame.name;
            });
            
            // Process samples and weights if available
            let totalTime = 0;
            const functionStats = {};
            
            if (profile.samples && profile.weights) {
                for (let i = 0; i < profile.samples.length; i++) {
                    const sample = profile.samples[i];
                    const weight = profile.weights[i];
                    totalTime += weight;
                    
                    // Credit the function at the top of the stack with this sample
                    if (sample.length > 0) {
                        const topFrameId = sample[sample.length - 1];
                        const frameName = frameLookup[topFrameId] || `Unknown Frame ${topFrameId}`;
                        
                        if (!functionStats[frameName]) {
                            functionStats[frameName] = { selfTime: 0, totalTime: 0 };
                        }
                        functionStats[frameName].selfTime += weight;
                        
                        // Credit all frames in the stack with total time
                        for (let j = 0; j < sample.length; j++) {
                            const frameId = sample[j];
                            const stackFrameName = frameLookup[frameId] || `Unknown Frame ${frameId}`;
                            
                            if (!functionStats[stackFrameName]) {
                                functionStats[stackFrameName] = { selfTime: 0, totalTime: 0 };
                            }
                            functionStats[stackFrameName].totalTime += weight;
                        }
                    }
                }
            }
            
            // Prepare summary
            const summaryHTML = `
                <h2>Profile Summary</h2>
                <p><strong>Profile Name:</strong> ${profile.name || 'Unnamed Profile'}</p>
                <p><strong>Total Time:</strong> ${totalTime.toFixed(2)} ms</p>
                <p><strong>Total Functions:</strong> ${Object.keys(functionStats).length}</p>
            `;
            document.getElementById('summary').innerHTML = summaryHTML;
            
            // Sort functions by self time
            const sortedFunctions = Object.entries(functionStats)
                .sort((a, b) => b[1].selfTime - a[1].selfTime)
                .slice(0, 50); // Show top 50
            
            // Display in table
            const tableBody = document.getElementById('allocTable').getElementsByTagName('tbody')[0];
            tableBody.innerHTML = '';
            
            sortedFunctions.forEach(([funcName, stats]) => {
                if (stats.selfTime > 0) {  // Only show functions with self time
                    const row = tableBody.insertRow();
                    
                    // Function name cell
                    const nameCell = row.insertCell(0);
                    nameCell.textContent = funcName;
                    
                    // Self time cell
                    const selfTimeCell = row.insertCell(1);
                    selfTimeCell.textContent = stats.selfTime.toFixed(2);
                    
                    // Total time cell
                    const totalTimeCell = row.insertCell(2);
                    totalTimeCell.textContent = stats.totalTime.toFixed(2);
                    
                    // Percentage cell
                    const pctCell = row.insertCell(3);
                    const pct = (stats.selfTime / totalTime * 100).toFixed(2);
                    pctCell.textContent = pct + '%';
                    
                    // Highlight allocation-related functions
                    if (funcName.includes('Alloc') || funcName.includes('alloc') || 
                        funcName.includes('new') || funcName.includes('New') ||
                        funcName.includes('Create') || funcName.includes('Memory')) {
                        row.style.backgroundColor = '#ffeeee';
                    }
                }
            });
        }
    </script>
</body>
</html>
